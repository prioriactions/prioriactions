% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evalTarget.R
\name{evalTarget}
\alias{evalTarget}
\title{Evaluate multiple target values}
\usage{
evalTarget(data = list(), prop = 1, ...)
}
\arguments{
\item{data}{\code{list}. Input data list for \code{problem()} function.}

\item{prop}{\code{numeric}. Proportion of maximum value of benefit to achieve. This
information can be getting with \code{getBenefit()} function.
More than one value is needed.}

\item{...}{arguments inherited from \code{problem()}, \code{minimizeCosts()},
and \code{solve()} functions.}
}
\value{
An object of class \linkS4class{portfolio}.
}
\description{
Provides multiple solutions for different values of target. This function
assumes that you are working with the \emph{minimizeCosts} model. Like
\code{prioriactions()} function, It inherits all arguments from \code{problem()},
\code{minimizeCosts()} and \code{solve()}.
}
\details{
\code{evalTarget()} creates and solves multiple multi-actions planning
problems for different values of targets You can do this by manually running
\code{prioriactions()} function with these different target values (i.e., running
once by target). However, the \code{evalTarget()} function has two advantages
over their counterpart: 1) it is more efficient to create the models.
This is because the model is once created and then updated with the
new information; 2) the output is a portfolio object, which allows
obtaining information about the group of solutions, including, all \emph{get}
functions and also different types of plots.
}
\examples{
# set seed for reproducibility
set.seed(14)

## Load data
inputs <- list(sim_pu_data, sim_features_data, sim_dist_features_data,
sim_threats_data, sim_dist_threats_data, sim_sensitivity_data,
sim_boundary_data)

## Create model and solve
port <- evalTarget(data = inputs, prop = c(0.1, 0.3, 0.5), time_limit = 50, output_file = FALSE)

plot(port)
}

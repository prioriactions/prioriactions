---
title: "Mitchell River"
output:
  rmarkdown::html_document:
    self_contained: yes
fontsize: 11pt
documentclass: article
vignette: >
  %\VignetteIndexEntry{Mitchell River}
  %\VignetteEngine{knitr::rmarkdown_notangle}
---

```{r setup, include = FALSE}
h <- 6
w <- 8
is_check <- ("CheckExEnv" %in% search()) || any(c("_R_CHECK_TIMINGS_",
             "_R_CHECK_LICENSE_") %in% names(Sys.getenv()))
knitr::opts_chunk$set(
  fig.align = "center", 
  eval = !is_check,
  collapse = TRUE,
  comment = "#>")
```

The Mitchell River is a river located in Far North Queensland, Australia. The river rises on the Atherton Tableland about 50 kilometres (31 mi) northwest of Cairns, and flows about 750 kilometres (470 mi) northwest across Cape York Peninsula from Mareeba to the Gulf of Carpentaria. we will use this case study to present some functionalities of the *prioriactions* package.

We started loading libraries:

```{r eval=FALSE, message=FALSE, warning=FALSE}
library(prioritizr) #To use the simulate features distribution
library(prioriactions)
library(raster) #To plot of shapefiles
library(tmap) #To create cool maps
library(scales) #To standardize the value of amount
library(reshape2) #To use the melt function
library(sp) #To use the spplot function
library(viridis) #To use viridis pallete
```

# Preparing data inputs

We divided the whole catchment (71,630 km2 into 2316 sites (i.e., sub-catchments), each one included the portion of river length between two consecutive river connections. We considered four major threats to freshwater fish species in the catchment: water buffalo (Bubalis bubalis), cane toad (Bufo marinus), river flow alteration (caused by impoundments, channels for water extractions and levee banks) and grazing land use. Also, we used the modelled spatial distribution of 45 fish species in the Mitchell river catchment as our conservation features. The distribution of features and threats () will be simulated while the other input files a *prioriactions* will be loaded directly from the package as follows:

```{r, fig.show='hold'}
path <- system.file("extdata/input_big/", package = "prioriactions")

pu_data <- data.table::fread(paste0(path,"unitCost_Big.csv"), data.table = FALSE)
features_data <- data.table::fread(paste0(path,"target_Big.csv"), data.table = FALSE)
bound_data <- data.table::fread(paste0(path,"boundary_Big.csv"), data.table = FALSE)
sensitivity_data <- data.table::fread(paste0(path,"sensibility_Big.csv"), data.table = FALSE)
```

We load the shapefile of the case study also included as part of the package installation:

```{r echo=TRUE, warning=FALSE}
#reading shapefile
shp_mitchell = raster::shapefile(paste0(path,"Mitchell.shp"))

sp::spplot(shp_mitchell, zcol = "Shape_Area", names.attr = "Area",
      main = "Planning unit areas", col.regions = viridis::viridis(20))
```

To model the distribution of features and threats, we use the function *simulate_species* from *prioritizr* package. Due this simulation is performed on a raster object, we rasterize the shapefile (through the *rasterize* function of the *raster* library) and then vectorize it again with the *extract* function of the same library.

```{r}
#We set the seed to can replicate the same simulations
set.seed(1)

#We transform the shapefile to raster with a convenient resolution for simulation
ext <- raster::extent(shp_mitchell)
r <- raster::raster(ext, res = 1000) 
r <- raster::rasterize(shp_mitchell, r, field=1)

#Simulation of 45 features distribution
dist_features <- prioritizr::simulate_species(r, 45, model = 	RandomFields::RMgauss(scale = 40000))

#We project the simulated rasters to shapefile
rij_data <- raster::extract(dist_features, shp_mitchell, fun = mean)
colnames(rij_data) <- features_data$id
```

In this way we obtain spatially auto correlated features distributions. Thus, for example, the distribution of simulated feature 1 is:

```{r warning=FALSE}
shp_mitchell$specie_distribution <- rij_data[,1]

#Plot distribution with tmap library
tmap::tm_shape(shp_mitchell) +
  tmap::tm_fill("specie_distribution", pal = c("white", "seagreen")) +
  tmap::tm_borders(col="black", lwd = 0.5)

```

Instead, the distribution of simulated threat 1 is:

```{r warning=FALSE}
#Simulation of 4 threats distribution
dist_threats <- prioritizr::simulate_species(r, 4, model = 	RandomFields::RMgauss(scale = 40000))

#We project the simulated rasters to shapefile
threats_data <- raster::extract(dist_threats, shp_mitchell, fun = mean)
colnames(threats_data) <- 1:4

shp_mitchell$threat_distribution <- threats_data[,1]

#Plot distribution with tmap library
tmap::tm_shape(shp_mitchell) +
  tmap::tm_fill("threat_distribution", pal = c("white", "red4")) +
  tmap::tm_borders(col="black", lwd = 0.5)
```

## 1) Model with presence / absence of threats and features

For the first prioritization exercise, we transform the amount data to values 0 and 1 for both features distribution and threats. In the case of features, a threshold of 0.5 was set, that is, if the value of the amount is equal to or greater than 0.5, it is considered that the features is present at the site. Instead, a threat is considered present if it has any non-zero amount value.

```{r warning=FALSE}
#Modifying continuous to binary amount data of features
rij_data_binary <- ifelse(rij_data > 0.5, 1, 0)
shp_mitchell$feature_distribution <- rij_data_binary[,1]

#Modifying continuous to binary amount data of threats
threats_data_binary <- ifelse(threats_data > 0.0, 1, 0)

#Plot example of feature distribution with tmap library
tmap::tm_shape(shp_mitchell) +
  tmap::tm_fill("feature_distribution", pal = c("white", "seagreen"), labels = c("0", "1"), breaks = c(0,1,2)) +
  tmap::tm_borders(col="black", lwd = 0.5)
```

Then, we create the features and threat distribution inputs in the corresponding format that will be used by the *prioriactions* package. Also, we modify the *features_data* to set the target of each feature at 15%.

```{r}
#Feature distribution data-------------------------------------
#We get the extended matrix of distribution data for both cases, set the specific col names and we are left with only positive values
rij_data_binary_large <- reshape2::melt(rij_data_binary)
colnames(rij_data_binary_large) <- c("pu", "species", "amount")
rij_data_binary_large <- rij_data_binary_large[rij_data_binary_large$amount > 0, ]

#threat distribution data-------------------------------------
threats_data_binary_large <- reshape2::melt(threats_data_binary)
colnames(threats_data_binary_large) <- c("pu", "threats", "amount")
threats_data_binary_large <- threats_data_binary_large[threats_data_binary_large$amount > 0, ]
threats_data_binary_large$cost <- 1
threats_data_binary_large$status <- 0

#features data-------------------------------------
features_data$target <- colSums(rij_data_binary)*0.15

```

## Base model

The base model considers the prioritization of conservation actions using the presence / absence of features and threats. In addition, a target has been set for all features of 15% of their representatives in the basin. The model, for its part, does not consider spatial requirements to the actions (*blm* and *blm_actions* parameters equal to 0. Furthermore, there is no attempt to optimize that planning actions occur within the same planning units (i.e., the *curve* parameter is equal to 1). The solver was configured to stop when a gap of at least 5% is achieved (0% meaning that at least one of the optimal solutions has been found).

```{r}
input_data.base <- prioriactions::problem(
  pu = pu_data, features = features_data, rij = rij_data_binary_large,
  threats = threats_data_binary_large, sensitivity = sensitivity_data,
  bound = bound_data
)
model.base <- prioriactions::min_costs(input_data.base, blm = 0, blm_actions = 0, curve = 1)
solution.base <- prioriactions::solve(model.base, gap_limit = 0.2, verbose = TRUE, output_file = FALSE)
```
Note that we have achieved a gap of 0.24% and a objective value of 1265. To obtain the distribution of conservation actions we use the *getSolutionActions()* function, while that to obtain the vector of sites that are incorporated into the conservation plan we use the *getSolutionUnits()* function. Note that planning units may be selected just for adding connectivity to the plan without taking action within these sites.

```{r warning=FALSE}
#Getting unit distribution selected
solution_units.base <- solution.base$getSolutionUnits()

#Assign solution to shapefile field to plot it
shp_mitchell$sol.base <-  solution_units.base$solution

#Plot of action 1 distribution
tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("sol.base", pal = c("white", "gray40"), labels = c("0", "1"), breaks = c(0,1,2)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

```

Whereas, if we want to obtain the actions to be carried out within the sites:

```{r warning=FALSE}
#Getting action distribution
solution_actions.base <- solution.base$getSolutionActions()

#Assign solution to shapefile field to plot it
shp_mitchell$action_1.base <-  solution_actions.base$`1`
shp_mitchell$action_2.base <-  solution_actions.base$`2`
shp_mitchell$action_3.base <-  solution_actions.base$`3`
shp_mitchell$action_4.base <-  solution_actions.base$`4`

#Actions plots
plot_action1.base <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("action_1.base", pal = c("white", "dodgerblue4"), labels = c("0", "1"), breaks = c(0,1,2)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

plot_action2.base <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("action_2.base", pal = c("white", "dodgerblue4"), labels = c("0", "1"), breaks = c(0,1,2)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

plot_action3.base <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("action_3.base", pal = c("white", "dodgerblue4"), labels = c("0", "1"), breaks = c(0,1,2)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

plot_action4.base <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("action_4.base", pal = c("white", "dodgerblue4"), labels = c("0", "1"), breaks = c(0,1,2)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

tmap::tmap_arrange(plot_action1.base , plot_action2.base , plot_action3.base , plot_action4.base)

```

Or the distribution of the sum of the actions (higher density of actions):
  
```{r warning=FALSE}
shp_mitchell$sum_actions.base <-  solution_units.base$solution + solution_actions.base$`1` + solution_actions.base$`2` + solution_actions.base$`3` + solution_actions.base$`4`

#Plot som of actions with tmap library
plot.base <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("sum_actions.base", palette="viridis", labels = c("do nothing", "pu selected without actions", "one action", "two actions", "three actions", "four actions"), breaks = c(0,1,2,3,4,5,6)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

plot.base
```
The results of this base model will be compared with the subsequent models generated.

## Model with different *curve* param

This model differs from the previous one in that it tries to group conservation actions within the selected sites as part of the management plan (through a non-linear relationship in the calculation of benefits). The latter is done by adding a value other than 1 to the *curve* parameter. Where: (1) indicates that there is a linear relationship between the quotient between the actions carried out with respect to the possible actions to be carried out with respect to the benefit obtained by a characteristic. (2) indicates a quadratic relationship between these values, and (3) a cubic relationship. In simple terms, the cubic relationship further penalizes not performing all conservation actions at a site for a particular feature.

```{r}
input_data.curve <- prioriactions::problem(
  pu = pu_data, features = features_data, rij = rij_data_binary_large,
  threats = threats_data_binary_large, sensitivity = sensitivity_data,
  bound = bound_data
)
model.curve <- prioriactions::min_costs(input_data.curve, blm = 0, blm_actions = 0, curve = 3)
solution.curve <- prioriactions::solve(model.curve, gap_limit = 0.2, verbose = TRUE, output_file = FALSE)
```

Note that the new model increased its dimensions compared to the previous one (from 11580 variables and 2361 constraints to 207844 variables and 160925 constraints), and therefore, increasing its resolution complexity. In this way, we obtain a value of the objective function of 1497 (greater than the previous one) with a quality of 4.48%.

```{r warning=FALSE}
#Getting unit distribution selected
solution_units.curve <- solution.curve$getSolutionUnits()

#Getting action distribution
solution_actions.curve <- solution.curve$getSolutionActions()

#Assign solution to shapefile field to plot it
shp_mitchell$action_1.curve <-  solution_actions.curve$`1`
shp_mitchell$action_2.curve <-  solution_actions.curve$`2`
shp_mitchell$action_3.curve <-  solution_actions.curve$`3`
shp_mitchell$action_4.curve <-  solution_actions.curve$`4`

shp_mitchell$sum_actions.curve <-  solution_units.curve$solution + solution_actions.curve$`1` + solution_actions.curve$`2` + solution_actions.curve$`3` + solution_actions.curve$`4`

#Plot som of actions with tmap library
plot.curve <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("sum_actions.curve", palette="viridis", labels = c("do nothing", "pu selected without actions", "one action", "two actions", "three actions", "four actions"), breaks = c(0,1,2,3,4,5,6)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

#Comparative with base model solution
tmap::tmap_arrange(plot.base, plot.curve)

```
Thus, we can notice that there are a greater number of sites with a higher density of actions with respect to the previous model (for example, a greater number of units painted yellow).

## Model with spatial requirements

To add spatial requirements to the model, there are two key parameters: *blm* which works in the same way as the parameter of the same name in *marxan*, which tries to minimize fragmentation between the selected planning units (i.e. regardless if conservation actions are carried out within them). Next we will see what happens when this parameter is relevant in the creation of the model.
  
```{r}
input_data.spatial_req<- prioriactions::problem(
  pu = pu_data, features = features_data, rij = rij_data_binary_large,
  threats = threats_data_binary_large, sensitivity = sensitivity_data,
  bound = bound_data
)
model.spatial_req <- prioriactions::min_costs(input_data.spatial_req, blm = 10, blm_actions = 0, curve = 1)
solution.spatial_req <- prioriactions::solve(model.spatial_req, gap_limit = 0.2, verbose = TRUE, output_file = FALSE)
```
In the same way as what happened in the previous model, it is naturally inferred that the spatial requirement implies higher costs in the management plan, as well as a model with greater computational complexity to resolve.

```{r warning=FALSE}
#Getting unit distribution selected
solution_units.spatial_req <- solution.spatial_req$getSolutionUnits()

#Getting action distribution
solution_actions.spatial_req<- solution.spatial_req$getSolutionActions()

#Assign solution to shapefile field to plot it
shp_mitchell$action_1.spatial_req <-  solution_actions.spatial_req$`1`
shp_mitchell$action_2.spatial_req <-  solution_actions.spatial_req$`2`
shp_mitchell$action_3.spatial_req <-  solution_actions.spatial_req$`3`
shp_mitchell$action_4.spatial_req <-  solution_actions.spatial_req$`4`

shp_mitchell$sum_actions.spatial_req <-  solution_units.spatial_req$solution + solution_actions.spatial_req$`1` + solution_actions.spatial_req$`2` + solution_actions.spatial_req$`3` + solution_actions.spatial_req$`4`

#Plot som of actions with tmap library
plot.spatial_req <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("sum_actions.spatial_req", palette="viridis", labels = c("do nothing", "pu selected without actions", "one action", "two actions", "three actions", "four actions"), breaks = c(0,1,2,3,4,5,6)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

#Comparative with base model solution
tmap::tmap_arrange(plot.base, plot.spatial_req)

```
As seen, minimizing fragmentation produced a more closely related conservation plan compared to the base model.

Another parameter to take into account is the *blm_actions* that adds the minimization of fragmentation between conservation actions, this means that it tries to spatially bring the management actions closer together and therefore, independently achieve a management plan as well related. 

```{r}
input_data.spatial_req_actions<- prioriactions::problem(
  pu = pu_data, features = features_data, rij = rij_data_binary_large,
  threats = threats_data_binary_large, sensitivity = sensitivity_data,
  bound = bound_data
)
model.spatial_req_actions <- prioriactions::min_costs(input_data.spatial_req_actions, blm = 0, blm_actions = 10, curve = 1)
solution.spatial_req_actions <- prioriactions::solve(model.spatial_req_actions, gap_limit = 0.2, verbose = TRUE, output_file = FALSE)
```
The effect of incorporating this parameter (*blm_actions*) can be seen better in the action distributions:

```{r warning=FALSE}
#Getting unit distribution selected
solution_units.spatial_req_actions <- solution.spatial_req_actions$getSolutionUnits()

#Getting action distribution
solution_actions.spatial_req_actions<- solution.spatial_req_actions$getSolutionActions()

#Assign solution to shapefile field to plot it
shp_mitchell$action_1.spatial_req_actions <-  solution_actions.spatial_req_actions$`1`
shp_mitchell$action_2.spatial_req_actions <-  solution_actions.spatial_req_actions$`2`
shp_mitchell$action_3.spatial_req_actions <-  solution_actions.spatial_req_actions$`3`
shp_mitchell$action_4.spatial_req_actions <-  solution_actions.spatial_req_actions$`4`

#Actions plots
plot_action1.spatial_req_actions <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("action_1.spatial_req_actions", pal = c("white", "dodgerblue4"), labels = c("0", "1"), breaks = c(0,1,2)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

plot_action2.spatial_req_actions <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("action_2.spatial_req_actions", pal = c("white", "dodgerblue4"), labels = c("0", "1"), breaks = c(0,1,2)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

plot_action3.spatial_req_actions <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("action_3.spatial_req_actions", pal = c("white", "dodgerblue4"), labels = c("0", "1"), breaks = c(0,1,2)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

plot_action4.spatial_req_actions <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("action_4.spatial_req_actions", pal = c("white", "dodgerblue4"), labels = c("0", "1"), breaks = c(0,1,2)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

tmap::tmap_arrange(plot_action1.spatial_req_actions , plot_action2.spatial_req_actions , plot_action3.spatial_req_actions , plot_action4.spatial_req_actions)
```

## 2) Model with continuous amount of threats and presence / absence of features

An interesting comparison is how the use of continuous threat intensities influences solutions with respect to the use of binary threat presence / absence data. To do this, we change the column *amount* for the original output from the simulation of threat distribution, without performing a previous filter, i.e.,

```{r}
#We get the extended matrix of distribution data for both cases, set the specific col names and we are left with only positive values

#threat distribution data-------------------------------------
threats_data_large <- reshape2::melt(threats_data)
colnames(threats_data_large) <- c("pu", "threats", "amount")
threats_data_large <- threats_data_large[threats_data_large$amount > 0, ]
threats_data_large$cost <- 1
threats_data_large$status <- 0
```

Thus, the new model is build as follow:

```{r}
input_data.threat_cont <- prioriactions::problem(
  pu = pu_data, features = features_data, rij = rij_data_binary_large,
  threats = threats_data_large, sensitivity = sensitivity_data,
  bound = bound_data
)
model.threat_cont<- prioriactions::min_costs(input_data.threat_cont, blm = 0, blm_actions = 0, curve = 1)
solution.threat_cont <- prioriactions::solve(model.threat_cont, gap_limit = 0.2, verbose = TRUE, output_file = FALSE)
```

```{r warning=FALSE}
#Getting unit distribution selected
solution_units.threat_cont <- solution.threat_cont$getSolutionUnits()

#Getting action distribution
solution_actions.threat_cont <- solution.threat_cont$getSolutionActions()

#Assign solution to shapefile field to plot it
shp_mitchell$action_1.threat_cont <-  solution_actions.threat_cont$`1`
shp_mitchell$action_2.threat_cont <-  solution_actions.threat_cont$`2`
shp_mitchell$action_3.threat_cont <-  solution_actions.threat_cont$`3`
shp_mitchell$action_4.threat_cont <-  solution_actions.threat_cont$`4`

shp_mitchell$sum_actions.threat_cont <-  solution_units.threat_cont$solution + solution_actions.threat_cont$`1` + solution_actions.threat_cont$`2` + solution_actions.threat_cont$`3` + solution_actions.threat_cont$`4`

#Plot som of actions with tmap library
plot.threat_cont <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("sum_actions.threat_cont", palette="viridis", labels = c("do nothing", "pu selected without actions", "one action", "two actions", "three actions", "four actions"), breaks = c(0,1,2,3,4,5,6)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

#Comparative with base model solution
tmap::tmap_arrange(plot.base, plot.threat_cont)

```


## 3) Model with continuous amount of threats and features

The more general model allows us to work with continuous data on intensity of species and threats. For this, the same procedure is carried out on the data done in the previous step, but now with the *amount* column of the features. Also, it is necessary to update the *target* column from the *features_data* file.

```{r}
#Feature distribution data-------------------------------------

rij_data_large <- reshape2::melt(rij_data)
colnames(rij_data_large) <- c("pu", "species", "amount")
rij_data_large <- rij_data_large[rij_data_large$amount > 0, ]

#features data-------------------------------------
features_data$target <- colSums(rij_data)*0.15

```

Thus, the new model is build as follow:

```{r}
input_data.feature_cont <- prioriactions::problem(
  pu = pu_data, features = features_data, rij = rij_data_large,
  threats = threats_data_large, sensitivity = sensitivity_data,
  bound = bound_data
)
model.feature_cont<- prioriactions::min_costs(input_data.feature_cont, blm = 0, blm_actions = 0, curve = 1)
solution.feature_cont <- prioriactions::solve(model.feature_cont, gap_limit = 0.2, verbose = TRUE, output_file = FALSE)
```

```{r warning=FALSE}
#Getting unit distribution selected
solution_units.feature_cont <- solution.feature_cont$getSolutionUnits()

#Getting action distribution
solution_actions.feature_cont <- solution.feature_cont$getSolutionActions()

#Assign solution to shapefile field to plot it
shp_mitchell$action_1.feature_cont <-  solution_actions.feature_cont$`1`
shp_mitchell$action_2.feature_cont <-  solution_actions.feature_cont$`2`
shp_mitchell$action_3.feature_cont <-  solution_actions.feature_cont$`3`
shp_mitchell$action_4.feature_cont <-  solution_actions.feature_cont$`4`

shp_mitchell$sum_actions.feature_cont <-  solution_units.feature_cont$solution + solution_actions.feature_cont$`1` + solution_actions.feature_cont$`2` + solution_actions.feature_cont$`3` + solution_actions.feature_cont$`4`

#Plot sum of actions with tmap library
plot.feature_cont <- tmap::tm_shape(shp_mitchell) + 
  tmap::tm_fill("sum_actions.feature_cont", palette="viridis", labels = c("do nothing", "pu selected without actions", "one action", "two actions", "three actions", "four actions"), breaks = c(0,1,2,3,4,5,6)) + 
  tmap::tm_borders(col="black", lwd = 0.5)

#Comparative with base model solution
tmap::tmap_arrange(plot.base, plot.feature_cont)

```
